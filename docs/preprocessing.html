---

title: Preprocessing


keywords: fastai
sidebar: home_sidebar

summary: "Functions for preprocessing fmri data and preparing stimulus and fmri data for training voxel-wise encoding models."
description: "Functions for preprocessing fmri data and preparing stimulus and fmri data for training voxel-wise encoding models."
nb_path: "preprocessing.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: preprocessing.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>Bad value in file Path(&#39;/home/mboos/.config/matplotlib/stylelib/mb.mplstyle&#39;), line 20 (&#39;grid.linewidth: white&#39;): Key grid.linewidth: Could not convert &#39;white&#39; to float
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="o">%</span><span class="k">load_ext</span> autoreload
<span class="o">%</span><span class="k">autoreload</span> 2
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Preprocessing-BOLD-fMRI">Preprocessing BOLD fMRI<a class="anchor-link" href="#Preprocessing-BOLD-fMRI"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="preprocess_bold_fmri" class="doc_header"><code>preprocess_bold_fmri</code><a href="https://github.com/mjboos/voxelwiseencoding/tree/master/voxelwiseencoding/preprocessing.py#L16" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>preprocess_bold_fmri</code>(<strong><code>bold</code></strong>, <strong><code>mask</code></strong>=<em><code>None</code></em>, <strong><code>detrend</code></strong>=<em><code>True</code></em>, <strong><code>standardize</code></strong>=<em><code>'zscore'</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Preprocesses BOLD data and returns ndarray of preprocessed data</p>
<p>Parameters</p>

<pre><code>bold : path to bold nifti file or loaded bold nifti
mask : path to mask nifti file or loaded mask nifti, optional
detrend : bool, whether to linearly detrend the data, optional
standardize : {‘zscore’, ‘psc’, False}, default is ‘zscore’
kwargs : further arguments for nilearn's clean function

</code></pre>
<p>Returns
    ndarray of the preprocessed bold data in (samples, voxels)</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><a href="/voxelwiseencoding/preprocessing.html#preprocess_bold_fmri"><code>preprocess_bold_fmri</code></a> preprocessed a BOLD Nifti and returns a numpy ndarray of the optionally masked and preprocessed fMRI data.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Aligning-stimulus-and-fMRI">Aligning stimulus and fMRI<a class="anchor-link" href="#Aligning-stimulus-and-fMRI"> </a></h2>
</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="make_X_Y" class="doc_header"><code>make_X_Y</code><a href="https://github.com/mjboos/voxelwiseencoding/tree/master/voxelwiseencoding/preprocessing.py#L156" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>make_X_Y</code>(<strong><code>stimuli</code></strong>, <strong><code>fmri</code></strong>, <strong><code>TR</code></strong>, <strong><code>stim_TR</code></strong>, <strong><code>lag_time</code></strong>=<em><code>6.0</code></em>, <strong><code>start_times</code></strong>=<em><code>None</code></em>, <strong><code>offset_stim</code></strong>=<em><code>0.0</code></em>, <strong><code>fill_value</code></strong>=<em><code>nan</code></em>, <strong><code>remove_nans</code></strong>=<em><code>True</code></em>)</p>
</blockquote>
<p>Creates (lagged) features and fMRI matrices concatenated along runs</p>
<p>Parameters</p>

<pre><code>stimuli : list, list of stimulus representations
fmri : list, list of fMRI ndarrays
TR : int, float, repetition time of the fMRI data in seconds
stim_TR : int, float, repetition time of the stimulus in seconds
lag_time : int, float, optional,
           lag to introduce for stimuli in seconds,
           if no lagging should be done set this to TR
start_times : list, list of int, float, optional,
              starting time of the stimuli relative to fMRI recordings in seconds
              appends fill_value to stimulus representation to match fMRI and stimulus
offset_stim : int, float, optional,
              time to offset stimulus relative to fMRI in the lagged stimulus,
              i.e. when predicting fmri at time t use only stimulus features
              before t-offset_stim. This reduces the number of time points used
              in the model.
fill_value : int, float, or any valid numpy array element, optional,
             appends fill_value to stimulus array to account for starting_time
             use np.nan here with remove_nans=True to remove fmri/stimulus samples where no stimulus was presented
remove_nans : bool, bool or float 0&lt;=remove_nans&lt;=1, optional
              True/False indicate whether to remove all or none
              stimulus/fmri samples that contain nans
              a proportion keeps all samples in the lagged stimulus that have
              lower number of nans than this proportion.
              Replace nans with zeros in this case.

</code></pre>
<p>Returns:
tuple of two ndarrays,
the first element are the (lagged) stimuli,
the second element is the aligned fMRI data</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Example">Example<a class="anchor-link" href="#Example"> </a></h3><p><a href="/voxelwiseencoding/preprocessing.html#make_X_Y"><code>make_X_Y</code></a> allows you to align the (preprocessed) fMRI and stimulus data by specifying fMRI <code>TR</code> and stimulus <code>stim_TR</code>, as well as the <code>lag_time</code> (how long a stimulus window should be in seconds to predict a single fMRI TR) and potential stimulus offsets.
Since we potentially want to preprocess and concatenate multiple runs, both <code>fmri</code> and <code>stimuli</code> are supposed to be lists. To process only a single run, you can use a list of one element.</p>
<p>Let's look at an example, where the stimulus is sample every 100 ms and fMRI every 2s, i.e. every fMRI sample corresponds to 20 stimulus samples.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">stim_TR</span><span class="p">,</span> <span class="n">TR</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mi">2</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now create a simulated <code>stimulus</code> object of 80 samples.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">stimulus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">80</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">stimulus</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>(80, 1)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>And an according <code>fmri</code> object of 4 samples and one voxel (since we TRs differ).</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">fmri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">)[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fmri</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>(4, 1)
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let's first align <code>fMRI</code> and <code>stimulus</code> without any offset or lag:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_X_Y</span><span class="p">([</span><span class="n">stimulus</span><span class="p">],</span> <span class="p">[</span><span class="n">fmri</span><span class="p">],</span> <span class="n">TR</span><span class="p">,</span> <span class="n">stim_TR</span><span class="p">,</span> <span class="n">lag_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset_stim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_times</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">assert</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stderr output_text">
<pre>/home/mboos/anaconda3/envs/mne/lib/python3.7/site-packages/ipykernel_launcher.py:50: RuntimeWarning: lag_time is equal to TR, no stimulus lagging will be done.
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We keep the original number of samples in fMRI, but represent stimulus (and hence X) by the number of samples per fmri TR: stimulus thus becomes a (4, 20) array.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Lagging-the-stimulus">Lagging the stimulus<a class="anchor-link" href="#Lagging-the-stimulus"> </a></h3><p>We can now call <a href="/voxelwiseencoding/preprocessing.html#make_X_Y"><code>make_X_Y</code></a> with the stimulus and fMRI TRs and a specified <code>lag_time</code>.
Here we want to use 4 seconds of the stimulus to predict fMRI, but do not want to shift <code>fmri</code> relative to <code>stimulus</code> (<code>offset_stim</code> is 0.).
This means that our encoding model can approximate a hemodynamic response function (HRF) by estimating a finite impulse response (FIR) that is 4 seconds long.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_X_Y</span><span class="p">([</span><span class="n">stimulus</span><span class="p">],</span> <span class="p">[</span><span class="n">fmri</span><span class="p">],</span> <span class="n">TR</span><span class="p">,</span> <span class="n">stim_TR</span><span class="p">,</span> <span class="n">lag_time</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">offset_stim</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">start_times</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">assert</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Shifting-the-stimulus">Shifting the stimulus<a class="anchor-link" href="#Shifting-the-stimulus"> </a></h3><p>We could also shift <code>fmri</code> relative to <code>stimulus</code>, to account for the delayed onset of the hemodynamic response - this is different than estimating the hemodynamic response from the window given by <code>lag_time</code>.
In practice this means we estimate an hemodynamic response function (HRF) by a FIR in the time period from -6s to -2s before each fMRI sample.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_X_Y</span><span class="p">([</span><span class="n">stimulus</span><span class="p">],</span> <span class="p">[</span><span class="n">fmri</span><span class="p">],</span> <span class="n">TR</span><span class="p">,</span> <span class="n">stim_TR</span><span class="p">,</span> <span class="n">lag_time</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">offset_stim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">start_times</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="k">assert</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Handling-out-of-recording-data">Handling out-of-recording data<a class="anchor-link" href="#Handling-out-of-recording-data"> </a></h3><p>Because of our shift we "lose" one sample, because by default <code>fill_value</code> fills values that lie outside the recording interval by NaNs and by default <code>remove_nans</code> specifies that all samples with NaNs are dropped.</p>
<p>To check that behavior, we see what we get when we don't remove NaNs:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_X_Y</span><span class="p">([</span><span class="n">stimulus</span><span class="p">],</span> <span class="p">[</span><span class="n">fmri</span><span class="p">],</span> <span class="n">TR</span><span class="p">,</span> <span class="n">stim_TR</span><span class="p">,</span> <span class="n">lag_time</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">offset_stim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">start_times</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">remove_nans</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We keep the original number of samples, but some are filled with NaNs now:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">60</span>
<span class="nb">print</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[[nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan
  nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan
  nan nan nan nan]
 [nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan nan
  nan nan  0.  1.  2.  3.  4.  5.  6.  7.  8.  9. 10. 11. 12. 13. 14. 15.
  16. 17. 18. 19.]
 [ 0.  1.  2.  3.  4.  5.  6.  7.  8.  9. 10. 11. 12. 13. 14. 15. 16. 17.
  18. 19. 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35.
  36. 37. 38. 39.]
 [20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37.
  38. 39. 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55.
  56. 57. 58. 59.]]
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can see that the first samples completely consists of NaNs, because by lagging and offsetting we assume that the   fMRI sample at time point t can be predicted by the time period in the stimulus of t-6s to t-2s.
However, we don't have any stimulus presented in that time!
In the second sample we can see that the first half of the stimulus still consists of NaNs: that's because for t=2s, the time period in the stimulus from t-6s to t-2s has only data for t=0s but not t=4s.
Keep in mind that the stimulus at t=0s corresponds to the first 2s of the stimulus (because we reshaped the stimulus TR to correspond to the 2s fmri TR).</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="generate_lagged_stimulus" class="doc_header"><code>generate_lagged_stimulus</code><a href="https://github.com/mjboos/voxelwiseencoding/tree/master/voxelwiseencoding/preprocessing.py#L55" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>generate_lagged_stimulus</code>(<strong><code>stimulus</code></strong>, <strong><code>fmri_samples</code></strong>, <strong><code>TR</code></strong>, <strong><code>stim_TR</code></strong>, <strong><code>lag_time</code></strong>=<em><code>6.0</code></em>, <strong><code>start_time</code></strong>=<em><code>0.0</code></em>, <strong><code>offset_stim</code></strong>=<em><code>0.0</code></em>, <strong><code>fill_value</code></strong>=<em><code>nan</code></em>)</p>
</blockquote>
<p>Generates a lagged stimulus representation temporally aligned with the fMRI data</p>
<p>Parameters</p>

<pre><code>stimuli : ndarray, stimulus representation of shape (samples, features)
fmri_samples : int, samples of corresponding fmri run
TR : int, float, repetition time of the fMRI data in seconds
stim_TR : int, float, repetition time of the stimulus in seconds
lag_time : int, float, or None, optional,
       lag to introduce for stimuli in seconds,
       if no lagging should be done set this to TR or None
start_time :  int, float, optional, default 0.
          starting time of the stimulus relative to fMRI recordings in seconds
          appends fill_value to stimulus representation to match fMRI and stimulus
offset_stim : int, float, optional, default 0.
          time to offset stimulus relative to fMRI in the lagged stimulus,
          i.e. when predicting fmri at time t use only stimulus features
          before t-offset_stim. This reduces the number of time points used
          in the model.
fill_value : int, float, or any valid numpy array element, optional, default np.nan
         appends fill_value to stimulus array to account for starting_time
         use np.nan here with remove_nans=True to remove fmri/stimulus samples where no stimulus was presented

</code></pre>
<p>Returns:
    ndarray of the lagged stimulus of shape (samples, lagged features)</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><a href="/voxelwiseencoding/preprocessing.html#generate_lagged_stimulus"><code>generate_lagged_stimulus</code></a> takes care of aligning fMRI and stimulus data, it is used internally by <a href="/voxelwiseencoding/preprocessing.html#make_X_Y"><code>make_X_Y</code></a>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_remove_idx" class="doc_header"><code>get_remove_idx</code><a href="https://github.com/mjboos/voxelwiseencoding/tree/master/voxelwiseencoding/preprocessing.py#L41" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_remove_idx</code>(<strong><code>lagged_stimulus</code></strong>, <strong><code>remove_nan</code></strong>=<em><code>True</code></em>)</p>
</blockquote>
<p>Returns indices of rows in lagged_stimulus to remove</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

