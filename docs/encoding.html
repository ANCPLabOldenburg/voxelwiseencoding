---

title: Training and validating voxel-wise encoding models


keywords: fastai
sidebar: home_sidebar

summary: "Functions for training independent Ridge regressions for a large number of voxels and validating their performance"
description: "Functions for training independent Ridge regressions for a large number of voxels and validating their performance"
nb_path: "encoding.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: encoding.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_ridge_plus_scores" class="doc_header"><code>get_ridge_plus_scores</code><a href="https://github.com/mjboos/voxelwiseencoding/tree/master/voxelwiseencoding/encoding.py#L21" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_ridge_plus_scores</code>(<strong><code>X</code></strong>, <strong><code>y</code></strong>, <strong><code>alphas</code></strong>=<em><code>None</code></em>, <strong><code>n_splits</code></strong>=<em><code>8</code></em>, <strong><code>scorer</code></strong>=<em><code>None</code></em>, <strong><code>voxel_selection</code></strong>=<em><code>True</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Returns ridge regressions trained in a cross-validation on n_splits of the data and scores on the left-out folds</p>
<p>Parameters</p>

<pre><code>X : ndarray of shape (samples, features)
y : ndarray of shape (samples, targets)
alphas : None or list of floats, optional
         Regularization parameters to be used for Ridge regression
n_splits : int, optional
scorer : None or any sci-kit learn compatible scoring function, optional
         default uses product moment correlation
voxel_selection : bool, optional, default True
                  Whether to only use voxels with variance larger than zero.
                  This will set scores for these voxels to zero.
kwargs : additional arguments transferred to ridge_gridsearch_per_target

</code></pre>
<p>Returns
    tuple of n_splits Ridge estimators trained on training folds
    and scores for all concatenated out-of-fold predictions</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><a href="/voxelwiseencoding/encoding.html#get_ridge_plus_scores"><code>get_ridge_plus_scores</code></a> is a convenience function that trains <code>n_splits</code> Ridge regressions in a cross-validation scheme and evaluates their performance on the respective test set.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="ridge_gridsearch_per_target" class="doc_header"><code>ridge_gridsearch_per_target</code><a href="https://github.com/mjboos/voxelwiseencoding/tree/master/voxelwiseencoding/encoding.py#L62" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>ridge_gridsearch_per_target</code>(<strong><code>X</code></strong>, <strong><code>y</code></strong>, <strong><code>alphas</code></strong>, <strong><code>n_splits</code></strong>=<em><code>5</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Runs Ridge gridsearch across alphas for each target in y</p>
<p>Parameters</p>

<pre><code>X : ndarray of shape (samples, features)
y : ndarray of shape (samples, targets)
alphas : None or list of floats, optional
         Regularization parameters to be used for Ridge regression
n_splits : int, optional
kwargs : keyword parameters to be transferred to Ridge regression

</code></pre>
<p>Returns
    Ridge regression trained on X, y with optimal alpha per target
    determined by KFold cross-validation</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Example">Example<a class="anchor-link" href="#Example"> </a></h1><p>First, we create some simulated <code>stimulus</code> and <code>fmri</code> data.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">stimulus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">fmri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can now use <a href="/voxelwiseencoding/encoding.html#get_ridge_plus_scores"><code>get_ridge_plus_scores</code></a> to estimate multiple <a href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html">Ridge</a> regressions, one for each voxel (that maps the stimulus representation to this voxel) and one for each split (trained on a different training set and evaluated on the held-out set).
Since sklearn's <code>Ridge</code> estimator allows multi-output, we get one <code>Ridge</code> object per split.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ridges</span><span class="p">,</span> <span class="n">scores</span> <span class="o">=</span> <span class="n">get_ridge_plus_scores</span><span class="p">(</span><span class="n">stimulus</span><span class="p">,</span> <span class="n">fmri</span><span class="p">,</span> <span class="n">n_splits</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ridges</span><span class="p">))</span>
<span class="n">ridges</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>3
</pre>
</div>
</div>

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[Ridge(alpha=array([1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000])),
 Ridge(alpha=array([1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000])),
 Ridge(alpha=array([1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000]))]</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Each <code>Ridge</code> estimator maps from the feature space to each voxel.
In our example, that means it has 10 (the number of voxels-9 independently trained regression models with 5 coeficients each (the number of features).</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">assert</span> <span class="n">ridges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coef_</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ridges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coef_</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>[[ 0.03091656 -0.00552985  0.01743601  0.01279568  0.01053411]
 [ 0.00238455  0.0045204   0.00256562 -0.00748261 -0.00547277]
 [-0.00422868 -0.02666707  0.01187212 -0.02378444  0.03065698]
 [ 0.03035251 -0.01177954  0.01668209 -0.0109779   0.01566495]
 [ 0.0076802  -0.01518692 -0.01891325 -0.00329026 -0.00599254]
 [-0.01751964  0.00928253  0.00283076  0.01285903 -0.02664727]
 [ 0.03044979  0.02130243  0.01450193 -0.00512366  0.0111223 ]
 [-0.00812324 -0.00502767 -0.00471382  0.00727634 -0.02175445]
 [ 0.03337194  0.01006145 -0.01272059 -0.01134752 -0.01544005]
 [ 0.00368844  0.01035971 -0.03002989 -0.01830897 -0.00994489]]
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We also get a set of scores (by default the <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">product moment correlation</a>, but you can supply your own via the <code>scorer</code> argument) that specifies how well we predict left-out data (with the usual caveats of using a correlation coefficient for evaluating it). In our case it is of shape (10, 3) because we predict 10 voxels and use a 3-fold cross-validation, i.e. we split 3 times.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">assert</span> <span class="n">scores</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="n">scores</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[-0.01731239, -0.03907288,  0.04493863],
       [ 0.00467211, -0.06636354, -0.0427261 ],
       [-0.02978713,  0.06524192,  0.06223558],
       [-0.03216798, -0.00690511, -0.02197701],
       [ 0.07491743,  0.06247747, -0.00317411],
       [-0.0297277 , -0.0455451 , -0.01514241],
       [ 0.09316656,  0.0493194 ,  0.0818891 ],
       [-0.01266644, -0.06847899, -0.06770772],
       [ 0.04326812,  0.08139216,  0.04508078],
       [ 0.06647038,  0.0544588 ,  0.02366174]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Of course we can also call specify which hyperparameters we want to use.
For example the values of the regularization parameter $\alpha$ we want to perform a gridsearch over or whether we want to normalize features.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">alphas</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">]</span>
<span class="n">ridges</span><span class="p">,</span> <span class="n">scores</span> <span class="o">=</span> <span class="n">get_ridge_plus_scores</span><span class="p">(</span><span class="n">stimulus</span><span class="p">,</span> <span class="n">fmri</span><span class="p">,</span> <span class="n">n_splits</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                       <span class="n">alphas</span><span class="o">=</span><span class="n">alphas</span><span class="p">,</span>
                                       <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">ridges</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">normalize</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

</div>
 

