---

title: Training and validating voxel-wise encoding models


keywords: fastai
sidebar: home_sidebar

summary: "Functions for training independent Ridge regressions for a large number of voxels and validating their performance"
description: "Functions for training independent Ridge regressions for a large number of voxels and validating their performance"
nb_path: "encoding.ipynb"
---
<!--

#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: encoding.ipynb
# command to build the docs after a change: nbdev_build_docs

-->

<div class="container" id="notebook-container">
        
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="get_ridge_plus_scores" class="doc_header"><code>get_ridge_plus_scores</code><a href="https://github.com/mjboos/voxelwiseencoding/tree/master/voxelwiseencoding/encoding.py#L21" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>get_ridge_plus_scores</code>(<strong><code>X</code></strong>, <strong><code>y</code></strong>, <strong><code>alphas</code></strong>=<em><code>None</code></em>, <strong><code>n_splits</code></strong>=<em><code>8</code></em>, <strong><code>scorer</code></strong>=<em><code>None</code></em>, <strong><code>voxel_selection</code></strong>=<em><code>True</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Returns ridge regressions trained in a cross-validation on n_splits of the data and scores on the left-out folds</p>
<p>Parameters</p>

<pre><code>X : ndarray of shape (samples, features)
y : ndarray of shape (samples, targets)
alphas : None or list of floats, optional
         Regularization parameters to be used for Ridge regression
n_splits : int, optional
scorer : None or any sci-kit learn compatible scoring function, optional
         default uses product moment correlation
voxel_selection : bool, optional, default True
                  Whether to only use voxels with variance larger than zero.
                  This will set scores for these voxels to zero.
kwargs : additional arguments transferred to ridge_gridsearch_per_target

</code></pre>
<p>Returns
    tuple of n_splits Ridge estimators trained on training folds
    and scores for all concatenated out-of-fold predictions</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p><a href="/voxelwiseencoding/encoding.html#get_ridge_plus_scores"><code>get_ridge_plus_scores</code></a> is a convenience function that trains <code>n_splits</code> Ridge regressions in a cross-validation scheme and evaluates their performance on the respectice held-out set.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_markdown rendered_html output_subarea ">
<h4 id="ridge_gridsearch_per_target" class="doc_header"><code>ridge_gridsearch_per_target</code><a href="https://github.com/mjboos/voxelwiseencoding/tree/master/voxelwiseencoding/encoding.py#L63" class="source_link" style="float:right">[source]</a></h4><blockquote><p><code>ridge_gridsearch_per_target</code>(<strong><code>X</code></strong>, <strong><code>y</code></strong>, <strong><code>alphas</code></strong>, <strong><code>n_splits</code></strong>=<em><code>5</code></em>, <strong>**<code>kwargs</code></strong>)</p>
</blockquote>
<p>Runs Ridge gridsearch across alphas for each target in y</p>
<p>Parameters</p>

<pre><code>X : ndarray of shape (samples, features)
y : ndarray of shape (samples, targets)
alphas : None or list of floats, optional
         Regularization parameters to be used for Ridge regression
n_splits : int, optional
kwargs : keyword parameters to be transferred to Ridge regression

</code></pre>
<p>Returns
    Ridge regression trained on X, y with optimal alpha per target
    determined by KFold cross-validation</p>

</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Example">Example<a class="anchor-link" href="#Example"> </a></h1><p>First, we create some simulated data of <code>stimulus</code> and <code>fmri</code>.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">stimulus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">fmri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can now use <a href="/voxelwiseencoding/encoding.html#get_ridge_plus_scores"><code>get_ridge_plus_scores</code></a> to estimate multiple <a href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.Ridge.html">Ridge</a> regressions, one for each voxel (that maps the stimulus representation to this voxel) and one for each split (trained on a different training set and evaluated on the held-out set).
Since sklearn's <code>Ridge</code> estimator allows multi-output, we only get a <code>Ridge</code> object per split.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ridges</span><span class="p">,</span> <span class="n">scores</span> <span class="o">=</span> <span class="n">get_ridge_plus_scores</span><span class="p">(</span><span class="n">stimulus</span><span class="p">,</span> <span class="n">fmri</span><span class="p">,</span> <span class="n">n_splits</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ridges</span><span class="p">))</span>
<span class="n">ridges</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>3
</pre>
</div>
</div>

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>[Ridge(alpha=array([1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000])),
 Ridge(alpha=array([1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000])),
 Ridge(alpha=array([1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000, 1000]))]</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We also get a set of scores (by default the <a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient">product moment correlation</a>, but you can supply your own via the <code>scorer</code> argument) that specifies how well we predict left-out data (with the usual caveats of using a correlation coefficient for evaluating it). In our case it is of shape (10, 3) because we predict 10 voxels and use a 3-fold cross-validation, i.e. we split 3 times.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">scores</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="n">scores</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>(10, 3)
</pre>
</div>
</div>

<div class="output_area">



<div class="output_text output_subarea output_execute_result">
<pre>array([[ 0.06290033, -0.00997016, -0.00792117],
       [-0.01301689,  0.02528423, -0.00265887],
       [ 0.00782036, -0.01969563, -0.044481  ],
       [ 0.01435211, -0.01384505, -0.04758541],
       [ 0.03499081, -0.01899065, -0.06801739],
       [ 0.08777199,  0.01931685,  0.08959935],
       [ 0.01563399, -0.03672842, -0.05399268],
       [-0.05259006, -0.02230779, -0.02272438],
       [-0.07706426, -0.01217039, -0.07071412],
       [-0.0412908 , -0.10162923, -0.00832372]])</pre>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

</div>
 

